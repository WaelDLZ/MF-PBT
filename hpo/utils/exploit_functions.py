"""Implement various exploit strategies for PBT

Main idea: return a filiation list

parent[i] = j

And if parent[i] == i, i won't mutate
"""

from collections.abc import Callable

import numpy as np


def winner_takes_all(share_best: float = 0.5) -> Callable:
    def winner_takes_all_func(sorted_players: np.ndarray) -> np.ndarray:
        n_total = len(sorted_players)
        n_best = int(share_best * n_total)
        parent = np.arange(n_total)

        winners = sorted_players[:n_best]
        losers = sorted_players[n_best:]

        n_sons = (n_total - n_best) // n_best

        for i in range(n_best):
            parent[losers[n_sons * i : n_sons * (i + 1)]] = [winners[i]] * n_sons

        return parent

    return winner_takes_all_func


def truncation(share_best: float = 0.25) -> Callable:
    def truncation_func(sorted_players: np.ndarray) -> np.ndarray:
        n_total = len(sorted_players)
        n_best = int(share_best * n_total)
        parent = np.arange(n_total)
        parent[sorted_players[-n_best:]] = sorted_players[:n_best]
        return parent

    return truncation_func


def random_search_exploitation(arg) -> Callable:
    def random_search_exploitation_func(sorted_players: np.ndarray) -> np.ndarray:
        parent = np.arange(len(sorted_players))
        return parent

    return random_search_exploitation_func


def tournament(k: int = 2) -> Callable:
    def tournament_func(sorted_players: np.ndarray) -> np.ndarray:
        n_total = len(sorted_players)
        parent = np.arange(n_total)
        population = list(range(n_total))

        # Rebuild scores
        scores = np.empty_like(sorted_players)
        for i in range(len(sorted_players)):
            scores[sorted_players[i]] = -i

        for player in range(n_total):
            competitors = [player] + list(
                np.random.choice(
                    population[:player] + population[player + 1 :],
                    replace=False,
                    size=k - 1,
                ),
            )

            winner = max(competitors, key=lambda x: scores[x])
            parent[player] = winner

        return parent

    return tournament_func
